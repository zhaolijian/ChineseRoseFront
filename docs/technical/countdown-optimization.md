# 倒计时功能优化文档

## 优化概述

本次优化确保了小程序进入后台时倒计时仍然准确，主要通过基于时间戳的计算方式替代简单的递减计数。

## 核心改进

### 1. 基于时间戳的准确计时

**原理**：
- 存储倒计时结束的绝对时间戳，而非剩余秒数
- 每次更新时基于当前时间与结束时间的差值计算剩余秒数
- 避免了后台运行时定时器暂停导致的计时不准确问题

**实现**：
```typescript
// 开始倒计时时，保存结束时间戳
const endTime = Date.now() + seconds * 1000
uni.setStorageSync(storageKey, endTime)

// 更新倒计时时，基于时间戳计算
const now = Date.now()
const remaining = Math.floor((endTime - now) / 1000)
```

### 2. onShow 生命周期恢复

**场景**：
- 用户从后台切回小程序时
- 页面重新显示时
- 需要恢复准确的倒计时状态

**实现**：
```typescript
// 在 onShow 中调用 restore() 重新同步倒计时
onShow(() => {
  restoreCountdown()
})
```

### 3. 优化的 restore 方法

**改进点**：
- 调用 restore 前先清除现有定时器，避免多个定时器并存
- 简化逻辑，减少重复代码
- 确保倒计时状态的一致性

## 测试覆盖

### 单元测试场景

1. **基础功能测试**
   - 倒计时开始和停止
   - 存储的正确使用
   - 定时器的清理

2. **时间戳准确性测试**
   - 基于时间戳的计算验证
   - 后台运行场景模拟
   - 极端情况处理（倒计时已结束）

3. **页面集成测试**
   - onLoad 时恢复倒计时
   - onShow 时恢复倒计时
   - 表单状态与倒计时的联动

## 使用示例

```typescript
// 在页面中使用
import { useCountdown } from '@/composables/useCountdown'

const { countdown, start, restore } = useCountdown()

// 页面加载时恢复
onLoad(() => {
  restore()
})

// 从后台返回时恢复
onShow(() => {
  restore()
})

// 发送验证码
const sendCode = () => {
  // 发送请求...
  start(60) // 开始60秒倒计时
}
```

## 技术债务处理

本次优化解决了以下技术债务：
- ✅ 小程序后台运行时倒计时不准确的问题
- ✅ 多个定时器并存的潜在问题
- ✅ 测试覆盖不足的问题

## 性能影响

- **内存占用**：优化后减少了不必要的定时器创建
- **计算开销**：每秒一次的时间戳计算，开销可忽略不计
- **存储访问**：仅在开始和恢复时访问存储，对性能无影响

## 后续建议

1. 考虑添加倒计时暂停/继续功能
2. 支持多个独立的倒计时实例
3. 添加倒计时结束的回调函数
4. 考虑使用 Web Worker 在后台持续计时（H5平台）